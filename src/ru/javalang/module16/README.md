## Модуль16 
# Лямбда-выражения
- Синтаксис лямбда-выражений.
- Ссылки на методы.
- Функциональные интерфейсы.

### Лямбда 
- Лямбда - представляет набор инструкций, которые можно выделить в отдельную переменную и затем многократно вызвать в различных местах программы

- Основу лямбда-выражения составляет лямбда-оператор, который представляет стрелку ->. Этот оператор разделяет лямбда-выражение на две части: левая часть содержит список параметров выражения, а правая собственно представляет тело лямбда-выражения, где выполняются все действия

- Лямбда-выражение не выполняется само по себе, а образует реализацию метода, определенного в функциональном интерфейсе. При этом важно, что функциональный интерфейс должен содержать только один единственный метод без реализации.

### Отложенное выполнение (deferred execution)

В одном месте программы определяется лямбда-выражение и затем можем его вызывать при необходимости неопределенное количество раз в различных частях программы. Отложенное выполнение может потребоваться, к примеру, в следующих случаях:

- Выполнение кода отдельном потоке
- Выполнение одного и того же кода несколько раз
- Выполнение кода в результате какого-то события
- Выполнение кода только в том случае, когда он действительно необходим и если он необходим

### Передача параметров в лямбда-выражение
Параметры лямбда-выражения должны соответствовать по типу параметрам метода из функционального интерфейса. При написании самого лямбда-выражения тип параметров писать необязательно, хотя в принципе это можно сделать, например:
````
operation = (int x, int y)->x+y;
````

Если метод не принимает никаких параметров, то пишутся пустые скобки, например:
````
()-> 30 + 20;
````
Если метод принимает только один параметр, то скобки можно опустить:
````
n-> n * n;
````
### Блоки кода в лямбда-выражениях
Блочные выражения обрамляются фигурными скобками. В блочных лямбда-выражениях можно использовать внутренние вложенные блоки, циклы, конструкции if, switch, создавать переменные и т.д. Если блочное лямбда-выражение должно возвращать значение, то явным образом применяется оператор return:
````
Operationable operation = (int x, int y)-> {
         
    if(y==0)
        return 0;
    else
        return x/y;
};
````
### Обобщенный функциональный интерфейс
Функциональный интерфейс может быть обобщенным, однако в лямбда-выражении использование обобщений не допускается. В этом случае нам надо типизировать объект интерфейса определенным типом, который потом будет применяться в лямбда-выражении. Например:
````
interface Operationable<T>{
    T calculate(T x, T y);
}
````

# Встроенные функциональные интерфейсы
В JDK 8 вместе с самой функциональностью лямбда-выражений также было добавлено некоторое количество встроенных функциональных интерфейсов, которые мы можем использовать в различных ситуациях и в различные API в рамках JDK 8. В частности, ряд далее рассматриваемых интерфейсов широко применяется в Stream API - новом прикладном интерфейсе для работы с данными.
````
interface Predicate<T> {
    boolean test(T t);
}
````

````
interface Consumer<T> {
    void accept(T t);
}
````

````
interface Function<T, R> {
    R apply(T t);
}
````

````
interface Supplier<T> {
    T get();
}
````

````
interface UnaryOperator<T> {
    T apply(T t);
}
````

````
public interface BinaryOperator<T> {
    T apply(T t1, T t2);
}
````

# Stream API

Начиная с JDK 8 в Java появился новый API - Stream API. Его задача - упростить работу с наборами данных, в частности, упростить операции фильтрации, сортировки и другие манипуляции с данными. Вся основная функциональность данного API сосредоточена в пакете java.util.stream.

Ключевым понятием в Stream API является поток данных. Вообще сам термин "поток" довольно перегружен в программировании в целом и в Java в частности. В одной из предыдущих глав рассматривалась работа с символьными и байтовыми потоками при чтении-записи файлов. Применительно к Stream API поток представляет канал передачи данных из источника данных. Причем в качестве источника могут выступать как файлы, так и массивы и коллекции.

Одной из отличительных черт Stream API является применение лямбда-выражений, которые позволяют значительно сократить запись выполняемых действий.

# BaseStream
В основе Stream API лежит интерфейс BaseStream
````
interface BaseStream<T , S extends BaseStream<T , S>>
````
###BaseStream 
BaseStream определяет базовый функционал для работы с потоками, которые реализуется через его методы:

- void close(): закрывает поток

- boolean isParallel(): возвращает true, если поток является параллельным

- Iterator<Т> iterator(): возвращает ссылку на итератор потока

- Spliterator<Т> spliterator(): возвращает ссылку на сплитератор потока

- S parallel(): возвращает параллельный поток (параллельные потоки могут задействовать несколько ядер процессора в многоядерных архитектурах)

- S sequential(): возвращает последовательный поток

- S unordered(): возвращает неупорядоченный поток

### Наследники BaseStream
От интерфейса BaseStream наследуется ряд интерфейсов, предназначенных для создания конкретных потоков:
- Stream<T>: используется для потоков данных, представляющих любой ссылочный тип

- IntStream: используется для потоков с типом данных int

- DoubleStream: используется для потоков с типом данных double

- LongStream: используется для потоков с типом данных long

### Способы создания Stream:
- Пустой стрим: Stream.empty()
- Стрим из List: list.stream()
- Стрим из Map: map.entrySet().stream()
- Стрим из массива: Arrays.stream(array)
- Стрим из указанных элементов: Stream.of("1", "2", "3")
#### Операторы (методы класса Stream)
- Промежуточные (“intermediate”, ещё называют “lazy”) — обрабатывают поступающие элементы и возвращают стрим. Промежуточных операторов в цепочке обработки элементов может быть много.
  - filter(Predicate predicate) фильтрует стрим, пропуская только те элементы, что проходят по условию (Predicate встроенный функциональный интерфейс, добавленный в Java SE 8 в пакет java.util.function. Проверяет значение на “true” и “false”);
  - map(Function mapper) даёт возможность создать функию с помощью которой мы будем изменять каждый элемент и пропускать его дальше (Функциональный интерфейс Function<T,R> представляет функцию перехода от объекта типа T к объекту типа R)
  - flatMap(Function<T, Stream<R>> mapper) — как и в случае с map, служат для преобразования в примитивный стрим.
- Терминальные (“terminal”, ещё называют “eager”) — обрабатывают элементы и завершают работу стрима, так что терминальный оператор в цепочке может быть только один.
  - forEach(Consumer action) – аналог for each (Consumer<T> выполняет некоторое действие над объектом типа T, при этом ничего не возвращая);
  - count() – возвращает количество елементов стрима:
  - collect(Collector collector) – метод собирает все элементы в список, множество или другую коллекцию, сгруппировывает элементы по какому-нибудь критерию, объединяет всё в строку и т.д.:
  - collect(Supplier supplier, BiConsumer accumulator, BiConsumer combiner) — тот же, что и collect(collector), только параметры разбиты для удобства (supplier поставляет новые объекты (контейнеры), например new ArrayList(), accumulator добавляет элемент в контейнер, combiner объединяет части стрима воедино);
  - reduce(T identity, BinaryOperator accumulator) — преобразовывает все элементы стрима в один объект(посчитать сумму всех элементов, либо найти минимальный элемент), cперва берётся объект identity и первый элемент стрима, применяется функция accumulator и identity становится её результатом. Затем всё продолжается для остальных элементов.
  - reduce(BinaryOperator accumulator) — такой же метод как и выше но отсутсвует начальный identity, им служит первый элемент стрима
  - findFirst() – вытаскивает первый элемент стрима:
  - allMatch(Predicate predicate) — возвращает true, если все элементы стрима удовлетворяют условию. Если встречается какой-либо элемент, для которого результат вызова функции-предиката будет false, то оператор перестаёт просматривать элементы и возвращает false:
  - anyMatch(Predicate predicate) — вернет true, если хотя бы один элемент стрима удовлетворяет условию predicate:
  - noneMatch(Predicate predicate) — вернёт true, если, пройдя все элементы стрима, ни один не удовлетворил условию predicate:


